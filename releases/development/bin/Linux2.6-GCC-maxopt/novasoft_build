#!/usr/bin/perl
#
# NOvA Offline master build script
#
# This script is designed to perform a complete
# rebuild of the nova code base.  It assumes
# that the code is managed by the SoftRelTools
# release management system and that the appropriate
# specializations to the SRT have been installed.
#
# In the case of the standard NOvA distributions
# these specializations are encapsulated in the
# SRT_NOVA package.  In order for changes in this
# package to propagate correctly across updates,
# it should be build and installed before anything
# else.
#
#
##############################################

#
# Configuration control and default parameters
$debug_level      = 0;
$skip_sys_command = 0;
$nway_parallel    = 1;         # Default parallelization level is serial
$ignore_errors="";
@all_stages = qw(clean codegen include depend libobjects lib checkdicts bin);
$srt_parallel=(system("type srt_parallel >/dev/null 2>&1") == 0) ?
  "srt_parallel" :
  "$ENV{SRT_PUBLIC_CONTEXT}/SRT_NOVA/scripts/srt_parallel";

use Getopt::Long;
Getopt::Long::config('bundling_override');

my %options;
GetOptions(\%options,
	   'rel=s',
	   'help|h',
	   'debug',
	   'failonerror',
     'ignore-errors|i',
	   'noclean',
	   'clean|c',
     'stageonly|s=s',
	   'test|t',
	   'log|l=s',
	   'parallel|p=i' => \$nway_parallel);

if (defined $options{'help'}) {
  print_help();
}

if(defined $options{'log'} ){
    $logfile = $options{'log'};
    open(STDOUT,">$logfile");
    print STDOUT "Starting FNAL NOvASoft Build at ";
    print STDOUT scalar localtime();
    print STDOUT "\n";
    open(STDERR,">>$logfile");
}

if (defined $options{'ignore-errors'}) {
  if (defined $options{'failonerror'}) {
    print STDERR "-failonerror and -ignore-errors are mutually exclusive.\n";
    exit(1);
  } else {
    $ignore_errors="-i";
  }
}

if ($options{'stageonly'}) {
  if ($options{clean}) {
    print STDERR "-clean and -stageonly are mutually exclusive.\n";
    exit(1);
  }
  unless (grep { $_ eq $options{'stageonly'} } @all_stages) {
    print STDERR "-stageonly \"$options{'stageonly'}\" not recognized\n";
    print STDERR "Choose from: ", join(', ', @all_stages), ".\n";
    exit(1);
  }
} elsif ($options{'clean'}) {
  print STDERR "WARNING: -clean is deprecated: use -stageonly clean instead.\n";
  $options{'stageonly'} = 'clean';
}

if (defined $options{'debug'} ){
  $srtqual = $ENV{"SRT_QUAL"};
  if( $srtqual!="debug" ){
   print STDERR "SRT not setup with SRT_QUAL=debug, can't build debug\n";
  }
}

if (defined $options{'rel'}) {
  $release = $options{'rel'};
}
else {
  if (defined $ENV{"SRT_BASE_RELEASE"}) {
    $release = $ENV{"SRT_BASE_RELEASE"};
  }
  else {
    print STDERR "No release is defined\n";
    exit(1);
  }
}

if (! (defined $ENV{'SRT_DIST'})) {
  print STDERR "SRT_DIST variable is not defined! Source srt/srt.[c]sh first.\n";
  print STDERR "Release $release not built.\n";
  exit(1);
}

$SRT_DIST = $ENV{"SRT_DIST"};
$release_dir = "$SRT_DIST/releases/$release";

#check to see if we are supposed to be building in a test release
if (defined $options{'test'}) {
  if (defined $ENV{"SRT_PRIVATE_CONTEXT"}) {
    $release_dir = $ENV{"SRT_PRIVATE_CONTEXT"};
  }
}

if (! (-e "$release_dir")) {
  print STDERR "Cannot build non-existent release '$release'\n";
  exit(1);
}
else {
  print STDOUT "Building release '$release' in $release_dir\n";
  chdir("$release_dir");
}

make_package_list();

# Modify our package list to consist only of packages that exist.
@package_list = (grep { -e "$_" } @package_list);

if ($nway_parallel == 1) {
  $options{'stageonly'} = 'all' unless $options{'stageonly'};
}

foreach my $stage ($options{'stageonly'} || @all_stages) {
  next if ($options{'noclean'} and $stage eq 'clean');
  do_one_stage_for($stage, @package_list);
  sleep 2;
}

if (-e "OnlineMonitoring" and (!$options{'stageonly'} or $options{'stageonly'} eq 'all')) {
  print STDOUT "Building novan executable for OnlineMonitoring\n";
  do_one_stage_for('tbin', 'OnlineMonitoring');
}

my $completion_msg =
($options{'stageonly'} and $options{'stageonly'} ne 'all') ? "$options{'stageonly'} stage of " : "";

if ($options{'rel'}) {
  $completion_msg = "${completion_msg}$options{'rel'} ";
}

if ($options{'debug'}) {
  $completion_msg = "${completion_msg} DEBUG ";
}

print STDOUT "Finished ${completion_msg}NOvA-ART Build at ",
  scalar localtime(), "\n";

1;

#.......................................................................

sub do_one_stage_for {
  my $stage = shift;
  my @plist = @_;
  my $nway_local = ($stage eq 'lib') ? 1 : $nway_parallel;
  my $return_code = 255;
  # Make sure we have SRT scripts available.
  do_sys_command("{ gmake -j $nway_parallel SoftRelTools.bin; gmake -j $nway_parallel SRT_NOVA.bin; } >/dev/null 2>&1");
  my $packages = join("\n", @plist);
  my $failopt = "";
  if ($options{'failonerror'}) {
    $failopt = '--halt soon,fail=1';
  }
  $return_code = do_sys_command("echo \"$packages\" | ${srt_parallel} --wc $failopt -k -j $nway_local gmake ${ignore_errors} {}.$stage 2>&1");
  if ( $options{'failonerror'} and $return_code != 0) {
    printf STDERR "%s STAGE FAILED with return_code \"$return_code\"\n", uc $stage;
    exit(1);
  }
  print STDOUT "==================================================================\n";
  printf STDOUT "====            %s%s STAGE COMPLETE                     ====\n",
    ' ' x (length('libobjects') - length($stage)), ucfirst $stage ;
  print STDOUT "==================================================================\n";
}

sub print_help {
    print STDOUT "**********************************************************************\n";
    print STDOUT "*                                                                    *\n";
    print STDOUT "*     Script to build a release that has already been imported.      *\n";
    print STDOUT "*                                                                    *\n";
    print STDOUT "*    Recognized arguments:                                           *\n";
    print STDOUT "*       -h or --help: print this message                             *\n";
    print STDOUT "*       -rel <release>: specify release to be updated                *\n";
    print STDOUT "*       -debug: build with debugging symbols on                      *\n";
    print STDOUT "*       -failonerror: exit with failure on a failed gmake            *\n";
    print STDOUT "*       -ignore-errors: build with \"-i\" option to gmake            *\n";
    print STDOUT "*         (mutually-exclusive with -failonerror)                     *\n";
    print STDOUT "*       -noclean: Do not clean each package before building.         *\n";
    print STDOUT "*       -stageonly <stage> or -s <stage>: Execute only the specified *\n";
    print STDOUT "*         build stage.                                               *\n";
    print STDOUT "*       -c or -clean: Only clean release                             *\n";
    print STDOUT "*       -t or -test: build test release                              *\n";
    print STDOUT "*       -l or -log <logfile>: stdout and stderr sent to logfile      *\n";
    print STDOUT "*       --parallel=N or -p N : Use N-way parallelism in build        *\n";
    print STDOUT "*                                                                    *\n";
    print STDOUT "**********************************************************************\n";
    exit(0);
}

#.......................................................................

sub do_sys_command {
#
# Perform system command, but only if flag is set.
#
  if ($skip_sys_command>0 || $debug_level>1) {
    print "% $_[0]\n";
    return 0;
  }
  if ($skip_sys_command==0) {
    return system($_[0]);
  }
}

sub make_package_list{
  @package_list =
    (
     "SoftRelTools",
     "SRT_NOVA",
     # DAQ
     "NovaDAQUtilities",
     "RawFileParser",
     "PackageVersion",
     "DAQDataFormats",
     "NovaDAQConventions",
     "DAQChannelMap",
     "ShmRdWr",
     "ShmMilliBlock",
     "DAQQualityCheck",
     "NovaDatabase",
     "DatabaseUtils",
     "EventDispatcher_CommandSet",
     "NovaTimingUtilities",
     # DDT
     "DAQUnpackUtils",
     "DDTBaseDataProducts",
     "DDTUtilities",
     #GSD# Temporarily take DDTCore out of the build
     #"DDTCore",
     "MoonShadowTrigger",
     "OnlineCalibration",
     "PatRec",
     "SlowMonopoleTrigger",
     "SuperNovaDDT",
     # OFFLINE
     "RawData",
     "SummaryData",
     "Database",
     "GeometryObjects",
     "CMap",
     "Utilities",
     "RunHistory",
     "Geometry",
     "IFDBSpillInfo",
     "CalibrationUtils",
     "RecoBaseHit",
     "RecoBase",
     "Simulation",
     "CalibrationDataProducts",
     "PhotonTransport",
     "ReadoutSim",
     "Calibrator",
     "Calibration",
     "BremShowerFilter",
     "CosmicExposureInfo",
     "MockDataDAQ",
     "OnlineMonitoring",
     "ChannelInfo",
     "CalHit",
     "EventGenerator",
     "EventSummary",
     "DQSpillFlags",
     "HoughTransform",
     "g4nova",
     "MCCheckOut",
     "MCCheater",
     "Demo",
     "NovaSimMixer",
     "MuonRemove",
     "TrackFit",
     "HoughTrack",
     "HoughVertex",
     "ElasticArms",
     "FuzzyKVertex",
     "DiscreteTracker",
     "Alignment",
     "Slicer",
     "TDSlicer",
     "Preselection",
     "NumuEnergy",
     "ReMId",
     "QEEventFinder",
     "MEFinder",
     "TimingFit",
     "CosRej",
     "TrackInfo",
     "Commissioning",
     "DetectorPerformance",
     "VertexDT",
     "VertexFinder",
     "Validation",
     "Filter",
     "ShowerLID",
     "RecoJMShower",
     "CelestialLocator",
     "Eval",
     "NDRockMuon",
     "LEM",
     "CVN",
     "RecVarPID",
     "NCID",
     "XnuePID",
     "OscLib",
     "XSecReco",
     "NueSandbox",
     "NumuSandbox",
     "NusSandbox",
     "StandardRecord",
     "Metadata",
     "MCReweight",
     "DataQuality",
     "CAFMaker",
     "HDF5Maker",
     "CAFAna",
     "NDAna",
     "RecoValidation",
     "EventDisplayServices",
     "EventDisplay",
     "NewEventDisplay",
     "DAQ2RawDigit",
     "TriggerMonitoring",
     "DDTConverters",
     "BreakPointFitter",
     "ZukCluster",
     "DSOResultPlotter",
     "ShowerE",
     "Supernova",
     "SupernovaUtilities",
     "GenieSNova",
     "ProductMorgue"
     #GSD# Temporarily remove FNEX from build
     #"FNEX"
    );
  $npackage = scalar @package_list;
}
